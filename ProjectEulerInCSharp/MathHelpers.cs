namespace ProjectEulerInCSharp
{
    using System;
    using System.Collections.Generic;
    using System.Linq;

    public static class MathHelpers
    {

        public static List<int> AllProductsOfXDigitNumbers(int xDigits)
        {
            int start = (int)Math.Pow(10, xDigits - 1); // e.g. when x is 3 > 10^(3 - 1) = 100
            int end = (int)Math.Pow(10, xDigits) - 1;   // e.g. when x is 3 > (10^3) - 1 = 999
            int count = end - start + 1;
            
            List<int> range = Enumerable.Range(start, count).ToList();
            List<int> products = new List<int>();

            range.ForEach(i => range.ForEach(j => products.Add(i * j)));

            return products.Distinct().ToList();
        }

        /// <summary>
        /// Unordered factors of the given number, including one and the number itself.
        /// </summary>
        public static List<int> FactorsOf(int n)
        {
            return MathHelpers.FactorsOf((long)n);
        }

        /// <summary>
        /// Unordered factors of the given number, including one and the number itself.
        /// </summary>
        public static List<int> FactorsOf(long n)
        {
            List<int> l = new List<int>();
            long limit = (long)Math.Sqrt(n) + 1;

            for (int i = 1; i <= limit; i++)
            {
                if (n.MultipleOf(i))
                {
                    l.Add(i);
                    l.Add((int)(n / i));
                }
            }
            l = l.Distinct().ToList();
            l.Remove(1);
            l.Remove((int)n);
            return l;
        }

        /// <summary>
        ///Each new term in the Fibonacci sequence is generated by adding the previous two terms. 
        ///By starting with 1 and 2, the first 10 terms will be:
        ///1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
        ///Return a list of all Fibonacci terms less that the given limit.
        /// </summary>
        /// <returns>An ordered collection containing part of the Fibonacci sequence.</returns>
        public static List<int> FibonacciNumbersUpTo(int limit)
        {
            if (limit < 0) { throw new ArgumentOutOfRangeException("limit", "too negative"); }

            List<int> l = new List<int>() { 1, 2 };
            do
            {
                l.Add(l[l.Count - 1] + l[l.Count - 2]);

            } while (l[l.Count - 1] <= limit);

            return l;
        }

        /// <summary>
        /// An unordered list containing the number's factors that are prime numbers.
        /// </summary>
        public static List<int> PrimeFactorsOf(long n)
        {
            return FactorsOf(n)
                .Where(f => f.IsPrime())
                .ToList();
        }

        /// <summary>
        /// The nth prime number, counting up from 2.
        /// </summary>
         public static long NthPrime(int n)
         {
            var nPrimes = FirstNPrimes(n);

            return nPrimes[n - 1];
        }

        /// <summary>
        /// The first n prime numbers, counting up from 2.
        /// </summary>
        private static IList<int> FirstNPrimes(int n)
        {
            IList<int> primes = null;
            int max = 10;
            var count = 0;
            while (count < n)
            {
                max *= 10;
                primes = PrimesBelowN(max);
                count = primes.Count;
            }

            return primes.ToList().GetRange(0, n);
        }

        /// <summary>
        /// A Pythagorean triplet is a set of three natural numbers, a .lt. b .lt. c, for which,
        ///         a2 + b2 = c2
        /// </summary>
        public static bool IsPythagoreanTriplet(int a, int b, int c)
        {
            return Math.Pow(a, 2) + Math.Pow(b, 2) == Math.Pow(c, 2);
        }

        /// <summary>
        /// The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
        /// </summary>
        public static long SumOfPrimesBelow(int below)
        {
            if (below < 2) throw new ArgumentException("below", "too small for primes");

            return PrimesBelowN(below).Select(c => (long)c).Sum();
        }

        /// <summary>
        /// Get all primes smaller than N
        /// </summary>
        private static IList<int> PrimesBelowN(int n)
        {
            var range = Enumerable.Range(1, n - 1);

            // Make a lookup of all N integers
            var isPrimes = range.ToDictionary(i => i, i => true);

            // Switch off 1 (1 is not prime)
            isPrimes[1] = false;

            // Switch off all multiples of 2, then multiples of 3 etc.
            for (int f = 2; f < n; ++f)
            {
                int candidate = 2 * f;
                while (candidate < n)
                {
                    isPrimes[candidate] = false;
                    candidate += f;
                }
            }

            // Convert the lookup to a list
            return range
                .Where(c => isPrimes[c])
                .ToList();
        }
    }
}
